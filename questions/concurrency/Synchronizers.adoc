= Synchronizers

== CyclicBarrier

CyclicBarrier in Java is a synchronizer introduced in JDK 5 on java.util.Concurrent

All threads which wait for each other to reach the barrier are called parties, CyclicBarrier is initialized with a number of parties to wait and threads wait for each other by calling CyclicBarrier.await() method which is a blocking method in Java and blocks until all Thread or parties call await().

await() is a blocking call but can be timed out or Interrupted by other threads.

If you look at CyclicBarrier it also does the same thing but it is different you can not reuse CountDownLatch once the count reaches zero while you can reuse CyclicBarrier by calling the reset() method which resets Barrier to its initial State.

What it implies that *CountDownLatch is good for one-time events* like application start-up time and CyclicBarrier can be used in case of the recurrent event like concurrently calculating a solution of the big problem etc.

Each thread calls await method in short duration but they don't proceed until all 3 threads reached the barrier, once all thread reaches the barrier, the barrier gets broker and each thread started their execution from that point.

https://github.com/eight9080/test/blob/master/src/main/java/com/example/concurent/CyclicBarrierExample.java[CyclicBarrierExample.java]

Output:
----
Output:
Thread 1 is waiting on the barrier
Thread 3 is waiting on the barrier
Thread 2 is waiting on the barrier
All parties have arrived at the barrier, lets play
Thread 3 has crossed the barrier
Thread 1 has crossed the barrier
Thread 2 has crossed the barrier
----

* CyclicBarrier can perform a completion task once all thread reaches to the barrier, This can be provided while creating CyclicBarrier.

* The thread will block on await() until all parties reach the barrier, another thread interrupts or await timed out

* If another thread interrupts the thread which is waiting on the barrier it will throw BrokernBarrierException

* CyclicBarrier.reset() put Barrier on its initial state, other thread which is waiting or not yet reached barrier will terminate with java.util.concurrent.BrokenBarrierException.

Read more: https://javarevisited.blogspot.com/2012/07/cyclicbarrier-example-java-5-concurrency-tutorial.html[Cyclic Barrier]


== CountDownLatch

CountDownLatch in Java is a kind of synchronizer which allows one Thread to wait for one or more Threads before starts processing.

* You can not reuse CountDownLatch once count is reaches zero, this is the main difference between CountDownLatch and CyclicBarrier

* Main Thread wait on Latch by calling *CountDownLatch.await()* method while other thread calls *CountDownLatch.countDown()* to inform that they have completed.

CountDownLatch works in latch principle, the main thread will wait until Gate is open. One thread waits for n number of threads specified while creating CountDownLatch in Java.

Any thread, usually the main thread of application, which calls CountDownLatch.await() will wait until count reaches zero or its interrupted by another Thread. All other threads are required to do a count down by calling CountDownLatch.countDown() once they are completed or ready to the job. as soon as count reaches zero, Thread awaiting starts running.

One of the disadvantages of CountDownLatch is that *it's not reusable* once count reaches zero you can not use CountDownLatch any more

https://github.com/eight9080/test/blob/master/src/main/java/com/example/concurent/CountDownLatchDemo.java[CountDownLatchDemo.java]

Output:
----
CacheService is Up
ValidationService is Up
AlertService is Up
All services are up, Application is starting now
----

Read more: https://javarevisited.blogspot.com/2012/07/countdownlatch-example-in-java.html[CountDownLatch]
