= Concurrent programming

== Thread

A thread is defined at the operating system level. +
A thread is a set of instructions. +

The JVM itself, the Java Virtual Machine, works with several threads:

- There are threads for the garbage collection.
- There are threads for the Just In Time compiler
- other technical threads.

A CPU with only one core -> this CPU can only do one thing at a time. +
If I have only one core, nothing is really happening at the same time.
All those little actions are just happening so fast, that it feels they are happening at the same time.

CPU with two cores. +
CPU is able to do two things at the same time. +

On a multi-core CPU, things are really happening at the same time. +
CPU is able to run several tasks at the same time.

=== CPU Time Sharing Using a Thread Scheduler

A thread-scheduler is going to share evenly, the CPU timeline, divided into time slices, to all the tasks that need to be run.

There are three reasons for the scheduler to pause a thread, and to run another thread:

-  the CPU resource should be shared equally among the threads (check priority)
- A thread might be waiting for some more data. (some input output, reading or writing data to a disk or to a network)
- a thread might be waiting for another thread to do something. (to release a resource)

=== Race condition

A race condition deals with the *access of data concurrently*.

Two different threads are trying to read and write the same variable or the same field, at the same time.

==== Singleton pattern

[source,java]
----
public class Singleton{
    private static Singleton instance;
    private Singleton() {}

    public static Singleton getInstance(){
        if(instance==null){
            instance = new Singleton();
        }
        return  instance;
    }
}
----

- not a good implementation, not thread safe

To prevent this -> Synchonization

== Synchronization

Synchronization prevents a block of code to be executed by more than one thread at the same time. +
From a technical point of view -> it will prevent the *thread scheduler* to give the hand to a thread that wants to execute the synchronized portion of code that has already been executed by another thread.

[source,java]
----
public class Singleton{
    private static Singleton instance;
    private Singleton() {}

    public static synchronized Singleton getInstance(){
        if(instance==null){
            instance = new Singleton();
        }
        return  instance;
    }
}
----

=== Under the hood

The singleton class is a class with a get instance method that we want to synchronize.

The Java machine uses a special object, called a *lock object*, that has a key. The lock object has only one single key.

 A. When a thread want to enter this protected method, this protected block of code, it will make a request on this lock object, give me your key.
  * If the lock object has the key available, it will give it to this thread, and this thread will be able to run the get instance method freely.
 B. If another thread wants to enter this synchronized block of code, it will make the same request on the lock object, but this time, the lock object has no key available for him.

==== Lock Object

*Lock* (monitor) - A special technical object that will hold the key. This key is defined internally in the object class. _Every Java object can play this role._

The synchronized keyword on a public static method of the singleton class -> the JVM uses the *singleton class object itself*. +
_All the classes in Java are represented by objects._

* synchronized static method -> the object chosen to hold the key is the *class object itself*.
* on a non-static method -> the instance of the class

* to use a dedicated, explicit object to conduct synchronization
private final object called key, synchronized block inside this method, pass this key object as a parameter of this synchronized keyword.

[source,java]
----
public class Person {
    private final Object key = new Object();

    public String init(){
        synchronized(key){
            // stuff
        }
    }
}
----

==== Multiple synchronized methods

[source,java]
----
public class Person {
    public synchronized String getName(){
        return "1";
    }

    public synchronized int getAge(){
        return 10;
    }
    public static create(){
        Person marry = new Person();
    }
}
----

If a thread wants to execute getName -> it will take the *key* from the lock object, thus preventing a red thread from executing getAge at the same time. -> the same key is used to synchronize both methods.

If we need to synchronize getName *independently* of getAge, then two lock objects in the person class need to be created, and synchronize the block of codes inside the methods on those two different objects.

Using the synchronized keyword on a method declaration, uses an implicit lock object, which is the class object in the case of a static method, or the instance object itself in the case of a non-static method.

If what we really want is to prevent two threads to execute the getName method at the same time, in all the instances of the person class, then we need our lock object to be bound not to each instance of our class, but to the class itself -> _the static field of the class person itself_

=== Reentrant Lock

*Locks are reentrant* -  When a thread holds a lock, it can enter a block synchronized on the lock it is holding. (inheritance)

=== Deadlock

Mary and John instances of the person class, a synchronized method that is calling another synchronized method. +
First method is synchronized using a red key, and the method called by this method is synchronised using a green key. This green protected method calls another method, the third one, protected also by the red key. The blue thread is going to take the red key, and begin to run this first method. And at the same time, the purple thread is going to take the green key, and to run the other method. At some point, the blue thread will need the green key to enter the green method, but the purple thread has it. So this blue thread has to wait. And the purple thread will arrive at the point of code where it needs the red key to continue to run. And unfortunately the red key is not available, because it is held by the blue thread.

*A deadlock situation is a situation where a thread T one holds a key that is needed by another thread T two. And the deadlock is the fact that T two also holds the key needed by T one. So as long as no thread releases its key, the situation is blocked, and called a deadlock.*

== Runnable Pattern to Launch Threads

Small Example

[source, java]
----
public class FirstRunnable {

	public static void main(String[] args) {

		Runnable runnable = () -> {
			System.out.println("I am running in " + Thread.currentThread().getName());
		};

		Thread t = new Thread(runnable);
		t.setName("My thread");

		t.start();
	}
}
----



